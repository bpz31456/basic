## 设计模式
> 模式的识别是识别它的意图，而非它的实现
> 算法解决高效的代码，设计模式是解决高质量的代码
> 设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，
>行为型模式是将不同的行为代码解耦，
>具体到观察者模式，它是将观察者和被观察者代码解耦
> 每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。
* 应对面试
* 提高复杂代码的设计和开发能力
* 读源码和框架事半功倍
* 职场发展做铺垫
### 评判代码质量
> 类似对一个人的评价的综合因素评价，有主观性，多个维度去判断
* 可维护性（maintainability），
  * 不破坏原有代码设计，不引入新的bug的情况下，能快速修改和添加代码
* 可读性（readability），
  * 代码被阅读的次数远远超过被编写和执行的次数，代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。
  * code review 是一个很好的测验代码可读性的手段
* 可扩展性（extensibility）
  * 不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点
* 灵活性（flexibility）
  * 一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活
  * 添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可
  * 实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用
  * 使用某组接口的时候，这组接口可以应对各种使用场景，满足各种不同的需求，这种接口就具有易用性
* 简洁性（simplicity），KISS 原则：“Keep It Simple，Stupid”
  * 思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。
  * //TODO
* 可复用性（reusability）DRY（Don’t Repeat Yourself）,尽量减少重复代码的编写，复用已有的代码
  * 继承、多态的一个功能就是提高可复用性
  * 接口的单一职责
  * 代码重构，解耦、高内聚、低耦合、模块化
* **可测试性**（testability）
### 面向对象、设计原则、设计模式、编码规范、重构的关系
> 写好高质量代码的方法论
* 面向对象（丰富的特性、可以实现复杂的设计，是设计原则、设计模式实现的基础）
  * 封装、抽象、继承、多态
  * 面向对象编程和面向过程编程的比较
  * 面向对象分析、面向对象设计、面向对象编程
  * 接口和抽象类的实现和区别各个场景
  * 基于接口而非实现的设计思想
  * 多用组合少用继承
  * 面向过程的贫血模型和面向对象充血模型
* 设计原则,设计模式的指导原则
  * SOLID 原则 -SRP 单一职责原则
  * SOLID 原则 -OCP 开闭原则
  * SOLID 原则 -LSP 里式替换原则
  * SOLID 原则 -ISP 接口隔离原则
  * SOLID 原则 -DIP 依赖倒置原则
  * DRY 原则、KISS 原则、YAGNI 原则、LOD 法则
* 设计模式，（**解决可扩展性问题**）针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。
  * 创建型
    * 常用，单例模式，工厂模式，创建者模式
    * 不常用，原型模式
  * 结构型
    * 常用，代理模式，桥接模式，装饰者模式，适配器模式
    * 不常用，门面模式，组合模式，享元模式
  * 行为型
    * 常用，观察者、责任链、模板、策略、迭代器、状态
    * 不常用，访问者、备忘录、命令、解释器、中介
* 编码规范（**解决可读性问题**），如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多
  * 《重构》《代码简洁大全》《代码大全》
* 代码重构,**持续重构**是保持代码质量不下降的有效手段，避免过度设计
  * 重构的目的（why），对象（what），时机（when），方法（how）
  * 保证不出错的技术手段，单元测试和代码的可测试性
  * 大重构（大规模高层次）和小重构（小规模低层次）
### 面向对象（OOP），类（class）、对象（Object）
> 面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元 
* 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，
能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言
* 封装、抽象、继承、多态
* 面向对象分析、面向对象设计、面向对象编程，对class进行分析和设计
  * 面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，
  包括程序被拆解为哪些类，每个类有哪些属性方法、类与类之间如何交互
* UML，统一建模语言，没怎么使用
### 封装、抽象、继承、多态
* 封装，封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据
  * 需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制
  * 类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性
* 抽象，隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的
  * 类的方法是通过编程语言中的“函数”这一语法机制来实现的。通过函数包裹具体的实现逻辑，这本身就是一种抽象
  * 抽象作为一种只关注功能点不关注实现的设计思路
  * 我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中，暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义
* 继承，继承是用来表示类之间的 is-a 关系
  * 多继承、单继承
  * 继承最大的优点是提高代码复用
  * 继承不宜层次过多
* 多态，子类可以替换父类
  * 多态这种特性也需要编程语言提供特殊的语法机制来实现
    * 编程语言要支持父类对象可以引用子类对象
    * 编程语言要支持继承
    * 编程语言要支持子类可以重写（override）父类中的方法
  * 可以利用接口类语法
  * 可以利用 duck-typing 语法（一些动态语言所特有的语法机制，具有相同方法名，就可以）
### 面向对象、面向过程、函数式编程
* 什么事面向对象编程和面向过程编程
  * 面向对象编程，类或对象组织代码，并将封装、抽象、继承、多态作为编写代码的基石，将数据和方法绑定到类中
  * 面向过程编程，以过程（函数）为编写代码的单元，以数据和方法分离为编程基础
* 面向对象编程比面向过程编程的优势
  * oop能够应对大规模复杂程序
    * 大规模程序是错综综复杂的网状结构
  * oop风格的代码更易复用，易扩展，易维护
    * 多态，继承，面向过程编程是不具备的
  * OOP 语言更加人性化、更加高级、更加智能
    * 指令到汇编到面向过程再到高级语言
* 为什么面向对象编程比面向过程编程更高级
* 有哪些看似面向对象编程实际是面向过程编程
  * 滥用getter、setter方法，退化，破坏了封装的特性，数据没有访问权限控制
    * 尽量不要实现setter方法，集合内部数据也可能被修改
  * 滥用全局变量和全局方法，静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。
    * 程序中所有用到的常量，都集中地放到这个 Constants 类中
      * 这样的设计会影响代码的可维护性，不好定位，可能版本冲突
      * 增加代码的编译时间。
      * 影响代码的复用性。
    * 优化方案，拆分 Constants为多个功能模块的Constants类
    * Utils 类存在的意义，相同功能避免代码重复
      * 继承也可实现代码重复
      * 如果无上下文继承关系，可以定义单独的Utils工具，不同的功能模块可以分开定义方法
  * 定义的数据和方法分开实现
      * MVC代码风格，Controller 层、Service 层、Repository 层，每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity
      数据和操作分开的编码方式
* 在面向对象编程中，为什么容易写出面向过程编程呢
  * 面向过程编程风格符合人类的流程化思维方式
  * 面向对象设计稍微麻烦
* 面向过程编程已经过时了吗？
  * 开发的是微小程序，或一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适
### 什么是抽象类和接口？区别在哪里？
> 抽象类更多的是为了代码复用，而接口就更侧重于解耦(实现和接口的解耦)
* 抽象类的使用场景（模板设计模式）
* 抽象类不允许被实例化，只能被继承。
* 抽象类可以包含属性和方法。
* 类继承抽象类，必须实现抽象类中的所有抽象方法。
* 接口不能包含属性（也就是成员变量）
* 接口只能声明方法，方法不能包含代码实现。
* 类实现接口的时候，必须实现接口中声明的所有方法。
* 抽象类是is-a，接口类（协议）是has-a
* 用抽象类模拟抽象（全部方法设置为abstract），用普通类模拟接口（所有方法抛出异常，需要子类继承并程序并重写），
### 为什么基于接口而非实现编程？
* Program to an interface, not an implementation，能提高代码质量
  * interface是协议或约定，是功能列表
  * 暴露稳定的接口，封装不稳定实现
  * 越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，
  而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。
  * 具体的接口定义，就是上层抽象出对外暴露的方法定义，通过具体业务场景做具体的逻辑实现
    * 函数的命名不能暴露任何实现细节
    * 封装具体的实现细节
    * 为实现类定义抽象的接口
* 是否需要为每个类定义接口？
  * 这条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。
  * 某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口,避免过度设计
* ImageStore imageStore = new PrivateImageStore(/*省略构造函数*/);这里的PrivateImageStore在这个客户端使用的时候，有没有什么办法写得更加优雅？//TODO
### 为何说要多用组合少用继承？如何决定该用组合还是继承？
* 为什么不推荐使用继承？
  * 继承层次过深、过复杂，也会影响到代码的可维护性
  * 最小知识原则（Least Knowledge Principle，也叫最少知识原则或者迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率
* 组合相比继承有哪些优势？
  * 接口表示具有某种行为特性
  * 实现改接口的默认公共实现类
  * 在其他子类中通过组合的方式，调用公共实现类做到委托的作用
  * 组合会消除继承的多层级问题
* 如何判断该用组合还是继承？
  * 如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。
  * 系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。
  * 一些设计模式会固定使用继承或者组合，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系
  而，模板模式（template pattern）使用了继承关系
  * 没有继承关系的类之间具有相公的功能，可以组合一个相同功能的类进入，而不用继承
  * 不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来重写这个函数
* 数据库层定义 Entity，在 Service 业务层定义 BO（Business Object），在 Controller 接口层定义 VO（View Object）。
大部分情况下，Entity、BO、VO 三者之间的代码有很大重复，但又不完全相同。
我们该如何处理 Entity（数据库查询出来）、BO（entity在Service层中转化为BO）、VO（在Controller层由Bo转化来） 代码重复的问题呢？//TODO
### 贫血模型的MVC架构违背OOP吗？
* 什么是贫血模型？什么是充血模型？
  * 后端项目分为 Repository 层、Service 层、Controller 层
  * 只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model），VO，BO，Entity
  * 贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格
  * 数据和对应的业务逻辑被封装到同一个类中，充血模型满足面向对象的封装特性，是典型的面向对象编程风格
  * 微服务中，领域驱动设计是用来指导划分服务
  * DDD与与贫血模型的传统开发模式的区别主要在 Service 层，Service 层包含 Service 类和 Domain 类两部分，
  Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑，传统贫血模型开发Service很重，而DDD开发的Service很轻
  数据和操作都在Domain中处理
* 为什么说基于贫血模型的传统开发模式违反 OOP?
  * 大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作
  * 充血模型的设计要比贫血模型更加有难度，面向对象的编程风格，一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑
  * 思维已固化，转型有成本
* 基于贫血模型的传统开发模式既然违反 OOP，那又为什么如此流行？
  * 基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发,如，包含各种利息计算模型、还款模型等复杂业务的金融系统，社保金的待遇计算等等。
  * 基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。
* 什么情况下我们应该考虑使用基于充血模型的 DDD 开发模式？
 * 充血模型的 DDD 的开发模式，充血模型的 DDD 的开发模式，需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。
 领域模型相当于可复用的业务中间层。
* 领域模型DDD中为什么还会有Service层，它有什么作用呢？
  * Service 类负责与 Repository 交流，Domain主要是做业务逻辑开发的
  * Service 类负责跨领域模型的业务聚合功能。
  * Service 类负责一些非功能性及与三方系统交互的工作。比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等。
* Controller 层和 Repository 层有必要改为充血模型吗？
  * 没有必要， Controller主要是暴露接口，Repository主要是数据库打交道
### 面向对象的分析
* 明确需求列表，迭代需求版本，得到精确的需求列表
* 产出需求描述
### 面向对象设计、面向对象编程
> 根据各个需求点描述，需求点需要进行分模块，把描述出功能点（每个功能点只负责做一件很小的事情，专业叫法是“单一职责”）列出，
>再把功能点归类，看是否形成各个类
* 产出为各种类
* 划分职责进而识别出有哪些类；
* 定义类及其属性和方法；
* 定义类与类之间的交互关系；
* 将类组装起来并提供执行入口。
* 类与类之间的关系，泛化（继承），实现，聚合（课程和学生之间的关系），组合（鸟类与翅膀的关系），关联（是聚合或者组合关系），
依赖（聚合或组合亦或是函数参数）
```text
//聚合关系
public class A{
    private B b;
    public A(B b){
        this.B = b;//这里的B是传递进来的一个引用，他的生命周期是自己的与A无关
    }
}
//组合关系
public class A{
    private B b;
    public A(){
        this.b = new B();//这里的B是在A对象里面构造的，生命周期在A里面
    }
}
//依赖关系
//以上两种都是依赖，关联关系，依赖还有一种很弱的关系如
public class A{
    public void test(B a){//这里B作为一个函数参数传入或返回值或局部变量，也属于依赖关系
        //ignore
    }
}
```
### 单一职责原则（SRP）
> 一个类只负责完成一个职责或者功能
* 如何判定一个类是否职责单一
* 我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，
如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构
  * 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；
  * 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；
  * 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；
  * 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
  * 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。
### 对扩展开放、修改关闭(OCP)
> 只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试 
> 开闭原则讲的就是代码的扩展性问题
* 要时刻具备扩展意识、抽象意识、封装意识，识别需要扩展的功能点做设计
* 常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态等）
* 识别出所有可能的扩展点，属性业务或熟悉系统本身，现成本不高的扩展点，比较确定的、短期内可能就会扩展
* 扩展性和可读性之间做权衡
### 里式替换（LSP）和多态的区别
> 子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，
>并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。
> 知道思想应该是“Design By Contract”，中文翻译就是“按照协议来设计”，应该按照协议约束的方法逻辑来实现
* 多态是一种语言特性，在父类可以运行的地方，子类也可以运行，但子类可能改变父类方法的实现逻辑，所以两种有很大区别
* 反例
  * 子类违背父类声明要实现的功能，父类中提供的 sortOrdersByAmount() 订单排序函数按照金额大小排序，子类实现按照创建日期排序
  * 子类违背父类对输入、输出、异常的约定，函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection），子类实现为抛出异常
  * 子类违背父类注释中所罗列的任何特殊说明，父类描述用户的提现金额不得超过账户余额，子类针对 VIP 账号实现了透支提现的功能
* 验证，拿父类的单元测试去验证子类的代码
### 接口隔离（ISP）
> 客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者
* 一组 API 接口集合单个 
  * 在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，
  单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。
* API 接口或函数
  * 函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现
* OOP 中的接口概念
  * Updater 热更新接口和 Viewer 试图展示接口，Config，基础配置信息接口
  * 根据不同的配置策略实现不同的接口，不要在一个Config中把所有功能（在Updater和Viewer）都定义为接口方法，不然很不灵活
  * 不要让接口的实现类和调用者，依赖不需要的接口函数
#### 与单一职责的区别
> 接口隔离提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一
### 控制反转、依赖反转、依赖注入
#### 控制反转（IOC）
> 控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计
* “控制”指的是对程序执行流程的控制
* “反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行,使用框架之后，整个程序的执行流程可以通过框架来控制,流程的控制权从程序员“反转”到了框架
* 模板设计模式、依赖注入就是两种控制反转的设计思路
#### 依赖注入（DI）
> 依赖注入是一种具体的编码技巧
> 不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用
* 它是编写可测试性代码最有效的手段
#### 依赖注入框架（DI Framework）
> 对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成 
> 只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，
>就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情
#### 依赖反转原则（DIP）
> 高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。
>除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions） 
* Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。
* Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。
### KISS (Simple and Stupid)原则和 YAGNI 原则
#### KISS(Simple and Stupid)
> 尽量保持简单。
* 本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。
* 不要过度设计
* 不要使用同事可能不懂的技术来实现代码
* 不要重复造轮子，要善于使用已经有的工具类库
#### YAGNI （You Ain’t Gonna Need It。）
> 不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计
* 不要在项目中提前引入不需要依赖的开发包
### DRY(Don’t Repeat Yourself)
> 不要写重复的代码
* 实现逻辑重复
* 功能语义重复
* 代码执行重复
* 应当尽量减少I/O 操作
#### 代码复用性（Code Reusability）
> 我们在开发新功能的时候，尽量复用已经存在的代码
* 减少代码耦合
* 满足代码职责原则
* 模块化
* 业务与非业务逻辑分离
* 通用代码下沉
* 继承、多态、抽象、封装
* 应用模板等设计模式
* 第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性
* 之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码

### 迪米特法则（LOD）
> 实现代码的“高内聚、松耦合”,“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发
> 每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。
>或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。
* 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。

### 需求分析
* 借鉴，爱因斯坦说过，“创造的一大秘诀是要懂得如何隐藏你的来源”
* 用户用例，模拟实际的场景，找到需求点
* 线框图
#### 积分赚取和兑换规则
#### 积分消费和兑换规则
#### 积分及其明细查询

### 系统设计
#### 合理地将功能划分到不同模块
1. 积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。
2. 积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等。
3. 所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护。
#### 设计模块与模块之间的交互关系
1. 同步接口调用
2. 利用消息中间件异步调用
#### 设计模块的接口、数据库、业务模型

### 业务开发
#### 接口设计、
#### 数据库设计
#### 业务模型设计（也就是业务逻辑）

### 为什么要分 MVC 三层开发？
* 分层能起到代码复用的作用
* 分层能起到隔离变化的作用
* 分层能起到隔离关注点的作用
* 分层能提高代码的可测试性
* 分层能应对系统的复杂性
### BO、VO、Entity 存在的意义是什么？
* VO、BO、Entity 可能存在大量的重复字段，甚至三者包含的字段完全一样。
  * VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则
  * 为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互
  * VO、BO、Entity 并非完全一样。
* 继承可以解决代码重复问题。我们可以将公共的字段定义在父类中，让 VO、BO、Entity 都继承这个父类，各自只定义特有的字段。
* 组合也可以解决代码重复的问题，将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复用这个类的代码
* 数据对象转换
  * “Entity 到 BO”和“BO 到 VO”
  * 数据对象转化工具，比如 BeanUtils、Dozer
* VO、BO、Entity 都是基于贫血模型的，需要定义每个字段的 set 方法，违背 OOP 的封装特性？
  * Entity 和 VO 的生命周期是有限的，都仅限在本层范围内
### 接口调用统计信息系统
#### 项目背景
> 我们希望设计开发一个小的框架，能够获取接口调用的各种统计信息，
>比如，响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile）、接口调用次数（count）、频率（tps） 等，
>并且支持将统计结果以各种显示格式（比如：JSON 格式、网页格式、自定义显示格式等）输出到各种终端（Console 命令行、
>HTTP 网页、Email、日志文件、自定义输出终端等），以方便查看。
#### 需求分析
* 功能性需求分析
  * 接口统计信息：包括接口响应时间的统计信息，以及接口调用次数的统计信息等。
  * 统计信息的类型：max、min、avg、percentile、count、tps 等。
  * 统计信息显示格式：Json、Html、自定义显示格式。
  * 统计信息显示终端：Console、Email、HTTP 网页、日志、自定义显示终端。
  * 统计触发方式：包括主动和被动两种。
  * 统计时间区间：框架需要支持自定义统计时间区间
  * 统计时间间隔：对于主动触发统计，我们还要支持指定统计时间间隔
* 非功能性需求分析
  * 易用性,框架是否易集成、易插拔、跟业务代码是否松耦合
  * 性能性，不能影响到业务系统正常使用
  * 扩展性，客户端在不知道系统源码的同时能够实现相应的接口按照业务统计相应的信息
  * 容错性，不能因为统计信息系统的异常而导致业务系统无法使用
  * 通用性，能够灵活应用到多种场景进行统计，比如 SQL 请求时间的统计信息、业务统计信息（比如支付成功率）
#### 系统设计
* TDD（测试驱动开发）和 Prototype（最小原型）的思想，迭代，分模块
* 数据采集，负责打点采集原始数据，包括记录每次接口请求的响应时间和请求时间
* 存储，负责将采集的原始数据保存下来，以便后面做聚合统计
* 聚合统计，负责将原始数据聚合为统计数据，比如：max、min、avg、pencentile、count、tps 等
* 显示，负责将统计数据以某种格式显示到终端，命令行、邮件、网页、自定义显示终端
##### 划分职责进而识别出有哪些类
* MetricsCollector 类负责提供 API，来采集接口请求的原始数据。
我们可以为 MetricsCollector 抽象出一个接口，但这并不是必须的，因为暂时我们只能想到一个 MetricsCollector 的实现方式。
* MetricsStorage 接口负责原始数据存储，RedisMetricsStorage 类实现 MetricsStorage 接口。
这样做是为了今后灵活地扩展新的存储方法，比如用 HBase 来存储。
* Aggregator 类负责根据原始数据计算统计数据。
* ConsoleReporter 类、EmailReporter 类分别负责以一定频率统计并发送统计数据到命令行和邮件。
至于 ConsoleReporter 和 EmailReporter 是否可以抽象出可复用的抽象类，或者抽象出一个公共的接口，我们暂时还不能确定。
##### 定义类及类与类之间的关系
##### 将类组装起来并提供执行入口
### 重构
> 合理、熟练地利用设计思想、原则、模式、编程规范等理论知识解决这些问题
* 对重构概括性的介绍，包括重构的目的（why）、对象（what）、时机（when）、方法（how）；
* 保证重构不出错的手段，这里我会重点讲解单元测试和代码的可测试性；
* 不同规模的重构，重点讲解大规模高层次重构（比如系统、模块、代码结构、类与类之间的交互等的重构）和小规模低层次重构（类、函数、变量等的重构）。
#### 重构的目的：为什么要重构（why）？
> 重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。
利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。
* 首先，重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。
* 其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的
* 最后，重构是避免过度设计的有效手段。
#### 重构的对象：到底重构什么（what）？
> 大规模高层次重构（以下简称为“大型重构”）和小规模低层次的重构（以下简称为“小型重构”）
* 大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等
* 小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。
#### 重构的时机：什么时候重构（when）？
> 持续重构,就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分
#### 重构的方法：又该如何重构（how）？
* 大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。保证代码仓库中的代码一直处于可运行、逻辑正确的状态
* 小规模低层次的重构，因为影响范围小，改动耗时短，随时都可以去做.
### 重构技术手段
> 最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）
#### 什么是单元测试？
> 单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。
>测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行。这是代码层级的测试。
#### 为什么要写单元测试？
> 单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）。
* 单元测试能有效地帮你发现代码中的 bug
* 写单元测试能帮你发现代码设计上的问题
  * 对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计得不够合理
* 单元测试是对集成测试的有力补充
  * 大部分异常情况都比较难在测试环境中模拟,通过Mock对象返回我们需要模拟的异常
  * 依赖注入之所以能提高代码可测试性，主要是因为，通过这样的方式我们能轻松地用 mock 对象替换依赖的真实对象。
* 写单元测试的过程本身就是代码重构的过程
* 阅读单元测试能帮助你快速熟悉代码
* 单元测试是 TDD 可落地执行的改进方案 
#### 如何编写单元测试？
> 写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。
* 单元测试框架有 Junit、TestNG、Spring Test
* 写单元测试真的是件很耗时的事情吗？
  * 编写单元测试尽管繁琐，但并不是太耗时
* 对单元测试的代码质量有什么要求吗？
  * 单元测试代码的质量可以放低一些要求
* 单元测试只要覆盖率高就够了吗？
  * 测试用例是否覆盖了所有可能的情况
* 写单元测试需要了解代码的实现逻辑吗？
  * 不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能
* 如何选择单元测试框架？
  * 团队内部需要统一单元测试框架
#### 如何在团队中推行单元测试？
* 主人翁意识（ownership）
* 团队没有建立对单元测试正确的认识
### 代码的可测试性
> 单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，
>它不需要测试所依赖的外部系统（分布式锁、Wallet RPC 服务）的逻辑正确性。
#### 什么是代码的可测试性？
> 就是针对代码编写单元测试的难易程度,如果很难为其编写单元测试，或者单元测试写起来很费劲，
>需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理
#### 如何写出可测试的代码？
* 利用依赖注入来提高代码的可测试性，
* 如何通过 mock、二次封装等方式解依赖外部服务
* 跟“时间”有关的“未决行为”逻辑。我们一般的处理方式是将这种未决行为逻辑重新封装。
#### 有哪些常见的不好测试的代码？
* 未决行为,代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码
* 全局变量,面向过程的编程风格,滥用全局变量也让编写单元测试变得困难
* 静态方法,面向过程的编程风格,导致代码不易测试,静态方法也很难 mock
* 复杂继承,底层子类在写单元测试的时候，要一个一个 mock 很多依赖对象，而且还需要查看父类代码，去了解该如何 mock 这些依赖对象
* 高耦合代码，一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要 mock 这十几个依赖的对象
### 解耦
* “解耦”为何如此重要？
  * 复杂的代码往往在可读性、可维护性上都不友好，需要通过解耦的手段来处理
* 如何判定代码是否需要“解耦”？
  * 看修改代码会不会牵一发而动全身
  * 模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。（阅读源码） 
* 如何给代码“解耦”？
  * 封装与抽象，封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口
  * 引入中间层能简化模块或类之间的依赖关系。（类似copyOnWrite）
    * 第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。
    * 第二阶段：新开发的代码依赖中间层提供的新接口。
    * 第三阶段：将依赖老接口的代码改为调用新接口。
    *第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。
  * 模块化
    * 不同的模块之间通过 API 来进行通信，每个模块之间耦合很小，每个小的团队聚焦于一个独立的高内聚模块来开发
    * 模块化思想更加本质的东西就是分而治之
  * 其他设计思想和原则
    * 单一职责原则
    * 基于接口而非实现编程
    * 依赖注入
    * 多用组合少用继承
    * 迪米特法则
### 改善代码规范（小规模重构）
* 命名
  1. 命名多长最合适？
    * 对于一些默认的、大家都比较熟知的词，我比较推荐用缩写
    * 对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。
    * 对于类名这种作用域比较大的，我更推荐用长的命名方式。
    * 类名不应该揭示太多实现细节，不然不易通用
  2. 利用上下文简化命名
    * 函数参数也可以借助函数这个上下文来简化命名
  3. 命名要可读、可搜索
    * 不要用一些特别生僻、难发音的英文单词来命名
    * 最好能符合整个项目的命名习惯
  4. 如何命名接口和抽象类？
    * 一种是加前缀“I”，表示一个 Interface。比如 IUserService，实现类命名为UserService
    * 不加前缀，比如 UserService，对应的实现类加后缀“Impl”
    * 带上前缀“Abstract”，比如 AbstractConfiguration；
    * 不带前缀“Abstract”
* 注释
  1. 注释到底该写什么？
    * 注释的目的就是让代码更容易看懂
    * 做什么、为什么、怎么做
    * 注释比代码承载的信息更多
    * 注释起到总结性作用、文档的作用。在注释中，关于具体的代码实现思路，我们可以写一些总结性的说明、特殊情况的说明
    * 一些总结性注释能让代码结构更清晰
  2. 注释是不是越多越好？
    * 注释太多和太少都有问题。太多，有可能意味着代码写得不够可读
    * 如果代码中一行注释都没有，那只能说明这个程序员很懒
    * 类和函数一定要写注释，而且要写得尽可能全面、详细
    * 函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。
* 类、函数多大才合适?
> 在团队、项目中保持风格统一，让代码像同一个人写出来的，整齐划一。
  * 类或函数的代码行数不能太多，但也不能太少
  * 对于函数代码行数的最大限制，那就是不要超过一个显示屏的垂直高度
* 一行代码多长最合适？
  * 一行代码最长不能超过 IDE 显示的宽度
* 善用空行分割单元块
  * 比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，
  为了让逻辑更加清晰，可以添加总结性注释，还可以使用空行来分割各个代码块。
  * 在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，
  我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。
* 四格缩进还是两格缩进？
  * 取决于个人喜好。只要项目内部能够统一就行了。
  * 跟业内推荐的风格统一、跟著名开源项目统一。
  * 一定不要用 tab 键缩进
* 大括号是否要另起一行？
  * 将括号放到跟语句同一行的风格
  * 团队统一、业内统一、跟开源项目看齐
* 类中成员的排列顺序
  * 成员变量排在函数的前面。
  * 成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）
  * 成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，先写 public 成员变量或函数，然后是 protected 的，最后是 private
  * 把有调用关系的函数放到一块。比如，一个 public 函数调用了另外一个 private 函数，那就把这两者放到一块
* 把代码分割成更小的单元块
  * 有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，
  让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性
* 避免函数参数过多
  * 函数包含 3、4 个参数的时候还是能接受的，大于等于 5 个的时候，我们就觉得参数有点过多了，会影响到代码的可读性
  * 将函数的参数封装成对象。
  * 函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数
* 勿用函数参数来控制逻辑
  * 不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑，
  违背了单一职责原则和接口隔离原则，建议将其拆成两个函数，可读性上也要更好。
  * 如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。
  * “根据参数是否为 null”来控制逻辑的情况。针对这种情况，我们也应该将其拆分成多个函数。
* 函数设计要职责单一
  * 对于函数的设计来说，更要满足单一职责原则
* 移除过深的嵌套层次
  * 代码嵌套层次过深往往是因为 if-else、switch-case、for 循环过度嵌套导致的。
    * 去掉多余的 if 或 else 语句
    * 使用编程语言提供的 continue、break、return 关键字，提前退出嵌套
    * 调整执行顺序来减少嵌套
    * 将部分嵌套逻辑封装成函数调用，以此来减少嵌套
    * 常用的还有通过使用多态来替代 if-else、switch-case 条件判断的方法
* 学会使用解释性变量
  * 常量取代魔法数字。
  * 使用解释性变量来解释复杂表达式。
* 项目、团队，甚至公司，一定要制定统一的编码规范，并且通过 Code Review 督促执行，这对提高代码质量有立竿见影的效果。
### ID 生成器需求背景介绍实战
#### 项目背景
> 后端业务系统的开发，为了方便在请求出错时排查问题，我们在编写代码的时候会在关键路径上打印日志。
>某个请求出错之后，我们希望能搜索出这个请求对应的所有日志，以此来查找问题的原因。 
>给每个请求分配一个唯一 ID，并且保存在请求的上下文（Context）中，比如，处理请求的工作线程的局部变量中。在 Java 语言中，
>我们可以将 ID 存储在 Servlet 线程的 ThreadLocal 中，或者利用 Slf4j 日志框架的 MDC（Mapped Diagnostic Contexts）来实现
>（实际上底层原理也是基于线程的 ThreadLocal）。每次打印日志的时候，我们从请求上下文中取出请求 ID，跟日志一块输出。
>这样，同一个请求的所有日志都包含同样的请求 ID 信息，我们就可以通过请求 ID 来搜索同一个请求的所有日志了。
#### 如何发现代码质量问题？
* 目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？
* 是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？
* 设计模式是否应用得当？是否有过度设计？
* 代码是否容易扩展？如果要添加新功能，是否容易实现？
* 代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？
* 代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？
* 代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？
* 代码是否实现了预期的业务需求？
* 逻辑是否正确？是否处理了各种异常情况？
* 日志打印是否得当？是否方便 debug 排查问题？
* 接口是否易用？是否支持幂等、事务等？
* 代码是否存在并发问题？是否线程安全？
* 性能是否有优化空间，比如，SQL、算法是否可以优化？
* 是否有安全漏洞？比如输入输出校验是否全面？
#### 重构实例
* 第一轮重构：提高代码的可读性
  * hostName 变量不应该被重复使用，尤其当这两次使用时的含义还不同的时候；
  * 将获取 hostName 的代码抽离出来，定义为 getLastfieldOfHostName() 函数；
  * 删除代码中的魔法数，比如，57、90、97、122；
  * 将随机数生成的代码抽离出来，定义为 generateRandomAlphameric() 函数；
  * generate() 函数中的三个 if 逻辑重复了，且实现过于复杂，我们要对其进行简化；
对 IdGenerator 类重命名，并且抽象出对应的接口。
* 第二轮重构：提高代码的可测试性
  * generate() 函数定义为静态函数，会影响使用该函数的代码的可测试性；
  * generate() 函数的代码实现依赖运行环境（本机名）、时间函数、随机函数，所以 generate() 函数本身的可测试性也不好。
* 第三轮重构：编写完善的单元测试
* 第四轮重构：所有重构完成之后添加注释
  * 注释不能太多，也不能太少，主要添加在类和函数上。
* 即便是非常简单的需求，不同水平的人写出来的代码，差别可能会很大。
* 知其然知其所以然，了解优秀代码设计的演变过程，比学习优秀设计本身更有价值。
* 锻炼具体代码具体分析的能力，把知识点恰当地用在项目中。
* 高手之间的竞争都是在细节。大的架构设计、分层、分模块思路实际上都差不多。
### 程序出错该返回啥？NULL、异常、错误码、空对象？
#### 函数出错应该返回啥？
* 返回错误码，
  * C 语言中没有异常这样的语法机制，因此，返回错误码便是最常用的出错处理方式。
  * 编程语言中有异常这种语法机制，那就尽量不要使用错误码
* 返回 NULL 值，NULL 来表示“不存在”这种语义
  * 以 get、find、select、search、query 等单词开头的查找函数，返回代表不存在语义的 NULL 值比返回异常更加合理
  * 项目中的其他类似查找函数都是如何定义的，只要整个项目遵从统一的约定即可
* 返回空对象
  * 空字符串和空集合替代NULL值
* 抛出异常对象
  * 对于代码 bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），使用非受检异常。
  * 可恢复异常、业务异常，比如提现金额大于余额的异常，使用受检异常
  * 团队的开发习惯，在同一个项目中，制定统一的异常处理规范即可。
  * 直接吞掉、原封不动地 re-throw、包装成新的异常 re-throw
  * 是否往上继续抛出，要看上层代码是否关心这个异常，或调用者所处环境是否理解这个异常
* 我们可以不在 private 函数中做 NULL 值或空字符串的判断。
* 将函数设置为 protected，是为了方便写单元测试。

### 单例模式Singleton
> 一个类只允许创建一个对象（或者实例）,
#### 单例模式的实现
* 为什么要使用单例？
  * 解决资源竞争问题
  * 数据在系统中只应保存一份，那就比较适合设计为单例类,配置类
  * ID 生成器
* 如何实现一种单例模式？
  * 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
  * 考虑对象创建时的线程安全问题；
  * 考虑是否支持延迟加载；
  * 考虑 getInstance() 性能是否高（是否加锁）。
* 单例存在哪些问题？
  * 使用方法有点类似硬编码（hard code）
  * 单例对 OOP 特性的支持不友好
    * 违背了基于接口而非实现的设计原则
    * 单例对继承、多态特性的支持也不友好
  * 单例会隐藏类之间的依赖关系
  * 单例对代码的扩展性不友好
    * 慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。
  * 单例对代码的可测试性不友好
    * 单例类这种硬编码式的使用方式，导致无法实现 mock 替换
  * 单例不支持有参数的构造函数
    * 创建完实例之后，再调用 init() 函数传递参数。
    * 将参数放到 getIntance() 方法中
    * 将参数放到另外一个全局变量中，推荐
* 单例与静态类的区别？
* 有何替代的解决方案？
  * 为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现，内部使用Atomicxxx类实现
  * 单例模式主要是保证对象只有一个，既可以通过单例模式来强制保证，也可以通过工厂模式、IOC 容器（比如 Spring IOC 容器）来保证，
  还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）
* 懒汉模式，在多线程中使用，在第一次使用的时候才会实例化对象
1. 需要多线程中使用
2. 有资源竞争问题
3. 对资源非原子性操作
* 懒汉模式
  * 是同步方法，性能低
* 双重检测
  * 并发度较高，在低版本java需要这种检测
* 饿汉模式，在第class加载的时候就已经创建了实例对象，私有化构造函数，fail-fast 的设计原则（有问题及早暴露）
  * 不能懒加载
* 基于静态内部类实现（在第一次使用的时候才会加载类）//TODO
  * JVM特性
* 基于枚举类型实现（）//TODO
  * JVM特性
#### 在集群模式中如何使用分布式单例模式
> 对象的唯一性的作用范围是什么呢？在进程内只允许创建一个对象
* 如何理解单例模式中的唯一性？
  * 线程内唯一、进程内唯一、进程间唯一、集群内唯一
* 如何实现线程唯一的单例？
  * 线程内单例模式，ThreadLocal 工具类，可以更加轻松地实现线程唯一单例
* java语言中的单例模式并非是进程内，而是类加载器（Class Loader）内唯一
* 如何实现集群环境下的单例？
  * 我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，
  需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。
  * 在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。
  在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。
  * 每次每个进程取出一段连续数字（ID生成器），保存到自己本地作为单例模式使用，减少进程间加锁操作的性能问题
* 如何实现一个多例模式？
  * 一个类可以创建多个相同类型的对象，但是个数是有限制的
  * 可以由ConcurrentHashMap实现
### 工厂模式（Factory Design Pattern）
> 解耦对象的创建和使用
* 什么时候该用工厂模式？
  * 类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。
  针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。
  * 尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。
  在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。
* 相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？
  * 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。
  * 代码复用：创建代码抽离到独立的工厂类之后可以复用。隔离复杂性：
  * 封装复杂的创建逻辑，调用者无需了解如何创建对象。控制复杂度：
  * 将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。
#### 简单工厂
> 简单工厂模式看作是工厂方法模式的一种特例
* 简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，
这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的。
#### 工厂方法
> 利用多态，消除简单工厂中一个create方法中的多个if分支
* 把工厂类抽象为接口，每种类型都实现一种工厂，对应生产一种实例类
* 工厂方法模式比起简单工厂模式更加符合开闭原则。
* 工厂的使用又会有一个新的问题，从多个if语句筛选实例类，转移到了多个语句筛选工厂类
  * 为了消除多个if带来的问题，可以再引入一个创建工厂的简单工厂模式，把所有的工厂类都用HashMap提前存储起来，通过key就能得到具体的工厂类
* 我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。
* 之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。
* 如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。
#### 抽象工厂（Abstract Factory）
> 在简单工厂和工厂方法中，类只有一种分类方式,根据配置文件格式（Json、Xml、Yaml……）
> 如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类(json,xml,yaml),也可以按照解析的对象(rule,system)
### Dependency Injection框架
#### 工厂模式和 DI 容器有何区别？
* DI 容器底层最基本的设计思路就是基于工厂模式的
* 一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，
而 DI 容器负责的是整个应用中所有类对象的创建
#### DI 容器的核心功能有哪些？
> Spring IOC、Google Guice
* 配置解析
  * 需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。
  容器读取配置文件，根据配置文件提供的信息来创建对象。
* 对象创建
  * 只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。
  * “反射”机制，它能在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。
* 对象生命周期管理
  * 简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，
  另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象
  * 是否为单例对象
  * 是否为懒加载模式
  * init-method
  * destroy-method
* 如何实现一个简单的 DI 容器？
  * 最小原型设计
    * 配置配置文件beans.xml
  * 提供执行入口
    * 提供ApplicationContext类和ClassPathXmlApplicationContext接口
  * 配置文件解析
* 核心工厂类设计
  * 反射得到配置文件中的各种配置项，一种动态加载类和创建对象的机制。
### 建造者模式（builder）
* 为什么需要建造者模式？
  * 具有多个配置变量时，需要使用创建者模式
  * 配置项之间存在依赖关系或者约束条件的校验逻辑
  * 配置项中需要有不可变类作为属性
  * builder 定义为内部类是一个很好地实践
  * 使用建造者模式来构建对象，代码实际上是有点重复的，ResourcePoolConfig 类中的成员变量，
  要在 Builder 类中重新再定义一遍
* 与工厂模式有何区别？
  * 工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象
  * 建造者模式是用来创建一种类型的复杂对象，通过设置不同的可选参数，“定制化”地创建不同的对象
### 原型模式
> 实现方式，深拷贝和浅拷贝
> 如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），
>在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象
* 原型模式的原理与应用
  * 那何为“对象的创建成本比较大”？
    * 象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），
    或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取
* 原型模式的实现方式：深拷贝和浅拷贝
  * 浅拷贝，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身
  * 深拷贝不仅仅会复制索引，还会复制数据本身。
  * java 中的Object 类的 clone()，属于浅拷贝，只会复制基础数据类型值，复制对象的索引
  * 深拷贝，递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。
  * 序列化和反序列化
### 代理模式（Proxy）
> 不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。
#### 代理模式实现
* 参照基于接口而非实现编程的设计思想，将原始类对象替换为代理类对象的时候，为了让代码改动尽量少，代理类和原始类需要实现相同的接口。
* 与被代理类实现相同的接口来代理原始类的功能，并增强一些额外功能。
* 如果与原始类没有相同的接口，可以使用继承原始类的方式实现功能代理
#### 动态代理的原理解析
* 实现代理需要把所有的方法重写，如果有很多方法或很多类就需要重复实现很多方法，
如果有 50 个要添加附加功能的原始类，那我们就要创建 50 个对应的代理类
* 动态代理（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，
而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。
* 动态代理底层依赖的就是 Java 的反射语法
#### 代理模式的应用场景
* 在业务系统中开发一些非功能性需求
  * 监控、统计、鉴权、限流、事务、幂等、日志
* 代理模式在 RPC、缓存中的应用（赋予了普通功能远程交互的能力）
  * RPC 框架也可以看作一种代理模式
  * 过远程代理，将网络通信、数据编解码等细节隐藏起来。
  客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。
* 我们再来看代理模式在缓存中的应用。（赋予功能的缓存能力）
  * 假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，
  在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。
### 桥接模式（Bridge）
> 将抽象和实现解耦，让它们可以独立变化。
> JDBC 驱动是桥接模式的经典应用
* JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。
具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”
* 消息通知桥接实例
  * 背景：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。
  通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。
  不同的紧急程度对应不同的通知渠道。比如，SERVE（严重）级别的消息会通过“自动语音电话”告知相关人员。
  * 分析：Notify这里就是统一抽象，向Notify内部动态的配置（配置文件、数据库动态获取等）具体实现的套件。
### 装饰器模式()
> 主要解决继承关系过于复杂的问题，通过组合来替代继承，它主要的作用是给原始类添加增强功能（功能相近），
>装饰器模式还有一个特点，那就是可以对原始类嵌套使用多个装饰器。
* 装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。
* 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。

### 代理模式和装饰器模式的区别
* 代理类附加的是跟原始类`无关的功能`，而在装饰器模式中，装饰器类附加的是跟原始类`相关的增强功能`。

### 适配器模式的原理与实现(Adapter)
> 这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，
>让原本由于接口不兼容而不能一起工作的类可以一起工作。
* 把某个已有的类适配到其他接口或类上
#### 类适配器
* 类适配器使用继承关系来实现
#### 对象适配器
* 对象适配器使用组合关系来实现

#### 在实际的开发中，到底该如何选择使用哪一种呢
* 如果 Adaptee 接口并不多，那两种实现方式都可以。
* 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，
那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，
比起对象适配器的实现方式，Adaptor 的代码量要少一些。
* 如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，
那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。
#### 应用场景
> 适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”。
* 封装有缺陷的接口设计
  * 假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。
* 统一多个类的接口设计
  * 某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑
  * 多个系统，每个系统都提供一种敏感词过滤器，在系统中，通过适配器模式把各个系统的敏感词过滤器适配聚合为一个统一的接口
* 替换依赖的外部系统
* 兼容老版本接口
* 适配不同格式的数据
#### 剖析适配器模式在 Java 日志中的应用
> 比较常用的有 log4j、logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。
* Slf4j 这个日志框架你肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，
并没有提供具体的实现，需要配合其他日志框架（log4j、logback……）
* Slf4j 也事先考虑到了这个问题，所以，它不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。
#### 代理、桥接、装饰器、适配器 4 种设计模式的区别
> 笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。
* 代理模式
> 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，
>主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。
* 桥接模式
> 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。
* 装饰器模式
> 装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。
* 适配器模式
> 适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，
>而代理模式、装饰器模式提供的都是跟原始类相同的接口。
### 门面模式
> 门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。
#### 门面模式的应用场景举例
* 解决易用性问题
  * 门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。
  * Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用
  * Linux 系统调用函数就可以看作一种“门面”
* 解决性能问题
  * 通过将多个接口调用替换为一个门面接口调用，减少网络通信成本
  * 如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。
* 解决分布式事务问题
  * 用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。
  * 利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。
### 组合模式(Composite)
> 主要是用来处理树形结构数据
> 将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。
* 动态地添加、删除某个目录下的子目录或文件；
* 统计指定目录下的文件个数；
* 统计指定目录下的文件总大小。
* 主要算法体现在树型结构的遍历节点后的处理，如组织架构图中遍历得道总共的工资和平均工资
### 享元模式Flyweight
> 享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。
* 它的代码实现非常简单，主要是通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的。
* 享元模式跟单例
* 享元模式跟缓存的区别
* 享元模式跟对象池
* 应用单例模式是为了保证对象全局唯一。
应用享元模式是为了实现对象复用，节省内存。
缓存是为了提高访问效率，而非复用。
池化技术中的“复用”理解为“重复使用”，主要是为了节省时间。
* 包装类型都是用了享元模式Flyweight，如：缓存Integer(-128~127)，Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。
* 只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，
直接引用常量池中已经存在的即可，就不需要再重新创建了。
* 享元模式对 JVM 的垃圾回收并不友好
### 观察者模式（Observer）
* 在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。
* 被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）
* 解耦观察者和被观察者
#### 实例，在一个注册动作完成时，后续执行其他行为（行为是经常变动的）
* 用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。
这种情况下，我们就需要频繁地修改 register() 函数中的代码，违反开闭原则。
* 把注册事件定义为一个被观察者，其中包含一个Handler链表，每次业务变动时，就通过被观察者的
handler注册功能添加或remove功能删除handler，时间触发后就执行handler内的指定方法。
#### 基于不同应用场景的不同实现方式
> 小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路
* 邮件订阅、RSS Feeds
* 同步阻塞的实现方式、异步非阻塞的实现方式、跨进程的实现方式
  * 实现方式的不同体现在被观察者通知观察者执行的实现，可用多线程通知，可用异步实现方式通知（EventBus实现），可用网络通信RPC方式通知（基于消息队列）
* EventBus，时间总线（Google Guava EventBus）
  * 框架解耦了业务与非业务的逻辑，只需要在框架中完成相应的处理
  * EventBus、AsyncEventBus，对外暴露的所有可调用接口
  * register()，可以接受任何类型（Object）的观察者
  * unregister()，从 EventBus 中删除某个观察者
  * post()，发送消息，并非把消息发送给所有的观察者，而是发送给可匹配的观察者。
  * @Subscribe 注解，识别参数类型自动匹配
* 隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。
### 模板模式（Template）
> 模板模式主要是用来解决复用和扩展两个问题
> 模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。
>模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。
* 复用
* 扩展
#### 回调（Callback）与模板模式
> 回调是一种双向调用关系,A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”
* Callback 更侧重语法机制的描述，Hook 更加侧重应用场景的描述。
* 回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系
* 模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系
* 回调更加灵活，回调是功能点扩展，模板模式定义一种实现流程，留下扩展点（必须实现）
### 策略（Strategy）
> 避免冗长的 if-else 或 switch 分支判断,提供框架的扩展点
>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。
* 解耦的是策略的定义、创建、使用这三部分
1. 策略的定义
  * 基于接口而非实现
2. 策略的创建
  * 根据 type 创建策略的逻辑抽离出来，放到工厂类中。
3. 策略的使用
  * 客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略
* 如何利用策略模式避免分支判断？
> 这得益于策略工厂类。在工厂类中，我们用 Map 来缓存策略，根据 type 直接从 Map 中获取对应的策略，从而避免 if-else 分支判断逻辑。
等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助“查表法”，
根据 type 查表（代码中的 strategies 就是表）替代根据 type 分支判断。
* 业务场景需要每次都创建不同的策略对象
> 就会把业务代码中的if-else转移到工厂类中
* 解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不至于过于复杂、代码量过多。
* 对于复杂代码来说，策略模式还能让其满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险。
### 职责链模式(Chain Of Responsibility)
> 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，
>并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。
* 在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，我们在框架这个代码范围内实现了开闭原则。
* 过滤器的实现
* 拦截器的实现
* 过滤器（Servlet Filter）、拦截器（Spring Interceptor）、插件（MyBatis Plugin）
### 状态模式（State）
>状态机的实现方式有多种，除了状态模式，比较常用的还有分支逻辑法和查表法
> Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。
>其中，事件也称为转移条件（Transition Condition）。
>事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。
* 分支逻辑法
  * 很多if-else，case等
  * 对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。
* 查表法
  * 除了用状态转移图来表示之外，状态机还可以用二维表来表示
  * 事件不复杂，状态很多
* 状态模式
  * 如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作（比如加减积分、写数据库，还有可能发送消息通知等等）
  * 事件复杂，状态不复杂
### 迭代器模式（Iterator）
> 用来遍历集合对象。这里说的“集合对象”也可以叫“容器”“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。
>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。
* 迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法
* 对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。
* 对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。
* 树有前中后序、按层遍历，图有深度优先、广度优先遍历
* 针对图的遍历，我们就可以定义 DFSIterator、BFSIterator 两个迭代器类，让它们分别来实现深度优先遍历和广度优先遍历。
* 将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。
这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。
* 每个容器都需要定义一种迭代器实现，如树、图等
* 迭代器模式主要作用是解耦容器代码和遍历代码？
* 一种是遍历的时候不允许增删元素，另一种是增删元素之后让遍历报错。
* Java 语言就是采用的这种解决方案，增删元素之后，让遍历报错
* 迭代器类是容器类的内部类
### 访问者模式
> 允许一个或者多个操作应用到一组对象上，解耦操作和对象本身
* 访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile），继承相同的父类（ResourceFile）或者实现相同的接口。
* 进行一系列不相关的业务操作（抽取文本、压缩等）
* 避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，
以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，
* 为什么支持双分派（Double Dispatch）的语言不需要访问者模式呢？
  * 执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。
  * Single Dispatch（java C++ 等），指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定
* Java 设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，
根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。
### 备忘录模式（Memento）
> 在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。
* 存储副本以便后期恢复
* 要在不违背封装原则的前提下，进行对象的备份和恢复。这部分不太好理解
* 主要是用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。
* 备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。
### 命令模式（Command）
> 命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），
>并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。
* 是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。
* 在游戏进行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。
* 一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理。
* 另一种实现思路是在一个线程内轮询接收请求和处理请求。对于 IO 密集型的业务来说，
它避免了多线程不停切换对性能的损耗，并且克服了多线程编程 Bug 比较难调试的缺点
* 把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。

### 解释器模式(Interpreter)
> 解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。
* 将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类
### 中介模式（Mediator）
> 中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。
>将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。
* 中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）
* 在观察者模式的应用场景中，参与者之间的交互关系比较有条理。
* 只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式

### 总结
* 设计的初衷是提高代码质量
* 提高代码的可读性、可扩展性、可维护性等
* 设计的应用场景是复杂代码
* 设计模式要干的事情就是解耦，也就是利用更好的代码结构将一大坨代码拆分成职责更单一的小类，让其满足高内聚低耦合等特性。
* 应用设计模式会提高代码的可扩展性，但同时也会带来代码可读性的降低
* 不要脱离具体的场景去谈设计
### 管理重要性
* 吹毛求疵般地执行编码规范
* 编写高质量的单元测试
* 不流于形式的 Code Review
* 开发未动、文档先行,在开发某个系统或者重要模块或者功能之前，我们应该先写技术文档，
然后，发送给同组或者相关同事审查，在审查没有问题的情况下再开发。
* 持续重构
### code review
* Code Review 践行“三人行必有我师”
* Code Review 能摒弃“个人英雄主义”
* Code Review 能有效提高代码可读性
* Code Review 是技术传帮带的有效途径,培养初级工程师的技术能力
* Code Review 保证代码不止一个人熟悉
* Code Review 能打造良好的技术氛围,加强自驱力
* Code Review 是一种技术沟通方式
* Code Review 能提高团队的自律性
### google guava
* 复用和业务无关
* 单元测试、编码规范方面
* 抽象功能模块，在实际开发中
* Builder，cache.*
* Immutable,所有的成员变量都通过构造函数一次性设置好，不暴露任何 set 等修改成员变量的方法。除此之外，因为数据不变，所以不存在并发读写问题，
因此不变模式常用在多线程环境下，来避免线程加锁。所以，不变模式也常被归类为多线程设计模式。
### 函数式编程(Functional Programming)
> 函数式编程因其编程的特殊性，仅在科学计算、数据处理、统计分析等领域，才能更好地发挥它的优势
* 函数式编程是程序面向数学的更底层的抽象，将计算过程描述为表达式。
* 面向过程的编程单元是函数，函数式编程的编程单元是无状态函数
* Java 引入 Lambda 表达式的主要作用是简化代码编写
* Stream 类
* 函数接口，就是接口
* Guava 对函数式编程的增强
* 会导致可读性变差
### 项目一
#### 需求分析，参数需求列表
* 功能性需求
  * 配置限流规则和提供编程接口（RateLimiter 类）验证请求是否被限流
* 非功能性需求
  * 框架的易用性、扩展性、灵活性、性能、容错性等。
  * 易用性，希望限流规则的配置、编程接口的使用都很简单
  * 易用性，提供各种不同的限流算法，比如基于内存的单机限流算法、基于 Redis 的分布式限流算法，能够让使用者自由选择。
  * 易用性，希望限流框架能非常方便地集成到使用 Spring 框架的项目中。
  * 扩展性、灵活性方面，希望支持不同格式（JSON、YAML、XML 等格式）、不同数据源（本地文件配置或 Zookeeper 集中配置等）的限流规则的配置方式
  * 灵活性，能够灵活地扩展各种限流算法
  * 性能方面，让限流框架尽可能低延迟，尽可能减少对接口请求本身响应时间的影响。
  * 容错性，为了提高系统的可用性、稳定性，不能因为限流框架的异常，反过来影响到服务本身的可用性。
  分布式限流算法依赖集中存储器 Redis。如果 Redis 挂掉了，限流逻辑无法正常运行，这个时候业务接口也要能正常服务才行。
#### 系统设计
* 限流规则
  * 调用方、接口、限流阈值、时间粒度
* 限流算法
  * 固定时间窗口限流算法、滑动时间窗口限流算法、令牌桶限流算法、漏桶限流算法。
* 限流模式
  * 单机限流和分布式限流。
  * 某个服务的某个实例的访问频率，某个服务的多个实例的总的访问频率进行限制
* 集成使用
  * 低侵入松耦合设计思想，与业务代码松耦合，替换、删除起来也更容易些。
  * 可以借鉴 MyBatis-Spring，开发一个 xxx-Spring 类库
#### 系统实现
> 优秀的代码是重构出来的，复杂的代码是慢慢堆砌出来的。小步快跑、逐步迭代是我比较推崇的开发模式。
* 在编程开发的同时，我们还是要考虑代码的扩展性，预留好扩展点。
* 划分职责识别类、定义属性和方法、定义类之间的交互关系、组装类并提供执行入口。
* 先完全不考虑设计和代码质量，先把功能完成，先把基本的流程走通，哪怕所有的代码都写在一个类中也无所谓。
* Review 最小原型代码
  * 目录设计、代码结构、模块划分、类的设计
  * 编写可扩展代码，关键是要建立扩展意识,接口抽象意识。
### 实例二
* 超时重试需要接口幂等的支持。
* 如何判断两次接口请求是重试关系？而非独立的两个业务请求？
  * 需要给同一业务请求一个唯一标识，也就是“幂等号”！，通过某种算法来随机生成没有业务含义的幂等号。
#### 需求分析
> 实现生成幂等号的功能；
>实现存储、查询、删除幂等号的功能。
* 需求分析整理方法，比如画线框图、写用户用例、基于测试驱动开发，框架最终被开发出来之后，它会如何被使用。
* 易用性，只需编写简单的配置以及少许代码，就能完成接入。
* 易用性，框架最好对业务代码低侵入松耦合，在统一的地方（比如 Spring AOP 中）接入幂等框架
* 性能方面，针对每个幂等接口，在正式处理业务逻辑之前，我们都要添加保证幂等的处理逻辑。
* 容错性方面，不能因为幂等框架本身的异常，导致接口响应异常，影响服务本身的可用性。
* 简单的配置和少量代码，就能将非幂等接口改造成幂等接口。
#### 设计
* 考虑处理的异常情况有很多，比如业务代码异常、业务系统宕机、幂等框架异常。
* 幂等号随着请求传递到接口实现方之后，接口实现方将幂等号解析出来，传递给幂等框架。幂等框架先去数据库（比如 Redis）中查找这个幂等号是否已经存在。
如果存在，说明业务逻辑已经或者正在执行，就不要重复执行了。如果幂等号不存在，就将幂等号存储在数据库中，然后再执行相应的业务逻辑。
* 幂等框架处理的三个业务场景
  * 第一个阶段是调用方发送请求并被实现方接收，
    * 第一个阶段出现异常，比如发送请求失败或者超时，幂等号还没有记录下来，重试请求会被执行，符合我们的预期。
  * 第二个阶段是执行接口对应的业务逻辑，
    * 
  * 第三个阶段是将执行结果返回给调用方
    * 如果第三个阶段出现异常，业务逻辑执行完成了，只是在发送结果给调用方的时候，失败或者超时了，
    这个时候，幂等号已经记录下来，重试请求不会被执行，也符合我们的预期。
* 第二个阶段执行异常
  * 业务代码异常处理
    * 不删除已经记录的幂等号，不允许重新执行同样的业务逻辑，因为再次重新执行也是徒劳的，还是会报告异常。
  * 系统异常
    * 将已经记录的幂等号删除，允许重新执行这段业务逻辑。因为在系统级问题修复之后（比如数据库恢复了），
    重新执行之前失败的业务逻辑，就有可能会成功。
* 业务系统宕机处理
* 幂等框架异常处理
  * 在幂等逻辑执行异常时，我们选择让接口请求也失败，相应的业务逻辑就不会被重复执行了。
  * 我们对某些异常的处理在工程上做了妥协，交由业务系统或者人工介入处理。
  异常情况考虑是否全面
### 实例三，灰度发布组件
> 怎么解决代码回滚成本比较高的问题呢？
#### 需求分析
> 调用方在替换某个接口的时候，先让小部分接口请求，调用新的 RESTful 接口，剩下的大部分接口请求，
>还是调用老的 RPC 接口，验证没有问题之后，再逐步加大调用新接口的请求比例，最终，将所有的接口请求，都替换成调用新的接口。
* 系统层面的灰度，往往不在代码层面上实现，一般是通过配置负载均衡或者 API-Gateway，来实现分配流量到不同版本的系统上。
* 灰度组件在业务系统启动的时候，会将这个灰度配置，按照事先定义的语法，解析并加载到内存对象中，
业务系统直接使用组件提供的灰度判定接口，给业务系统使用，来判定某个灰度对象是否灰度执行新的代码逻辑。
* 